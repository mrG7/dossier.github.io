<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>dossier.models.pairwise &mdash; dossier 0.3.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="dossier 0.3.0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">dossier 0.3.0 documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for dossier.models.pairwise</h1><div class="highlight"><pre>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">.. This software is released under an MIT/X11 open source license.</span>
<span class="sd">   Copyright 2012-2014 Diffeo, Inc.</span>

<span class="sd">Active learning pairwise search engines</span>
<span class="sd">=======================================</span>
<span class="sd">.. autofunction:: similar</span>
<span class="sd">.. autofunction:: dissimilar</span>
<span class="sd">.. autoclass:: PairwiseFeatureLearner</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">ifilter</span><span class="p">,</span> <span class="n">imap</span><span class="p">,</span> <span class="n">islice</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">operator</span>

<span class="kn">from</span> <span class="nn">sklearn.feature_extraction</span> <span class="kn">import</span> <span class="n">DictVectorizer</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics.pairwise</span> <span class="kn">import</span> <span class="n">pairwise_distances</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>

<span class="kn">from</span> <span class="nn">dossier.label</span> <span class="kn">import</span> <span class="n">CorefValue</span><span class="p">,</span> <span class="n">expand_labels</span>
<span class="kn">from</span> <span class="nn">dossier.web</span> <span class="kn">import</span> <span class="n">engine_index_scan</span><span class="p">,</span> <span class="n">streaming_sample</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="n">itget</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span>


<div class="viewcode-block" id="similar"><a class="viewcode-back" href="../../../dossier.models.html#dossier.models.pairwise.similar">[docs]</a><span class="k">def</span> <span class="nf">similar</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">label_store</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;An active learning search engine that returns similar results.</span>

<span class="sd">    This satisfies the :class:`dossier.web.SearchEngine` interface.</span>

<span class="sd">    In addition to the standard query inputs of ``content_id``,</span>
<span class="sd">    ``filter_pred``, and ``limit``, this search engine has optional</span>
<span class="sd">    parameters ``canopy_limit`` and ``label_limit`` that restrict</span>
<span class="sd">    the number of candidates loaded for in-memory ranking and the</span>
<span class="sd">    number of labels used for model training, respectively.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">create_search_engine</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">label_store</span><span class="p">,</span> <span class="n">similar</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="dissimilar"><a class="viewcode-back" href="../../../dossier.models.html#dossier.models.pairwise.dissimilar">[docs]</a><span class="k">def</span> <span class="nf">dissimilar</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">label_store</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;An active learning search engine that returns dissimilar results.</span>

<span class="sd">    This satisfies the :class:`dossier.web.SearchEngine` interface.</span>

<span class="sd">    In addition to the standard query inputs of ``content_id``,</span>
<span class="sd">    ``filter_pred``, and ``limit``, this search engine has optional</span>
<span class="sd">    parameters ``canopy_limit`` and ``label_limit`` that restrict</span>
<span class="sd">    the number of candidates loaded for in-memory ranking and the</span>
<span class="sd">    number of labels used for model training, respectively.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">create_search_engine</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">label_store</span><span class="p">,</span> <span class="n">similar</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">create_search_engine</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">label_store</span><span class="p">,</span> <span class="n">similar</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="c"># N.B. `limit` caps the final results returned by the ranker.</span>
    <span class="c"># This is distinct from `canopy_limit` and `label_limit`, where</span>
    <span class="c"># they are used to keep resource use in check.</span>
    <span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">content_id</span><span class="p">,</span> <span class="n">filter_pred</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span>
          <span class="n">canopy_limit</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">label_limit</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Creates an active learning search engine.</span>

<span class="sd">        This is a helper function meant to satisfy the interface of</span>
<span class="sd">        a search engine with a particular active learning model.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c"># Are these maximums good enough? No idea. ---AG</span>
        <span class="n">canopy_limit</span> <span class="o">=</span> <span class="n">str_to_max_int</span><span class="p">(</span><span class="n">canopy_limit</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="n">label_limit</span> <span class="o">=</span> <span class="n">str_to_max_int</span><span class="p">(</span><span class="n">label_limit</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>

        <span class="n">learner</span> <span class="o">=</span> <span class="n">PairwiseFeatureLearner</span><span class="p">(</span>
            <span class="n">store</span><span class="p">,</span> <span class="n">label_store</span><span class="p">,</span> <span class="n">content_id</span><span class="p">,</span>
            <span class="n">canopy_limit</span><span class="o">=</span><span class="n">canopy_limit</span><span class="p">,</span> <span class="n">label_limit</span><span class="o">=</span><span class="n">label_limit</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">candidate_probs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">learner</span><span class="o">.</span><span class="n">probabilities</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="n">similar</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itget</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">InsufficientTrainingData</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;Falling back to plain index scan...&#39;</span><span class="p">)</span>
            <span class="n">index_scan</span> <span class="o">=</span> <span class="n">engine_index_scan</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">index_scan</span><span class="p">(</span><span class="n">content_id</span><span class="p">,</span> <span class="n">filter_pred</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>

        <span class="n">ranked</span> <span class="o">=</span> <span class="n">ifilter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">filter_pred</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">candidate_probs</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">imap</span><span class="p">(</span><span class="k">lambda</span> <span class="p">((</span><span class="n">cid</span><span class="p">,</span> <span class="n">fc</span><span class="p">),</span> <span class="n">p</span><span class="p">):</span> <span class="p">(</span><span class="n">cid</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;probability&#39;</span><span class="p">:</span> <span class="n">p</span><span class="p">}),</span>
                       <span class="n">ranked</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s">&#39;results&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">limit</span><span class="p">)),</span>
        <span class="p">}</span>
    <span class="k">return</span> <span class="n">_</span>


<span class="k">class</span> <span class="nc">InsufficientTrainingData</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="PairwiseFeatureLearner"><a class="viewcode-back" href="../../../dossier.models.html#dossier.models.pairwise.PairwiseFeatureLearner">[docs]</a><span class="k">class</span> <span class="nc">PairwiseFeatureLearner</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;A pairwise active learning model.</span>

<span class="sd">    This active learning model applies</span>
<span class="sd">    :class:`~sklearn.linear_model.LogisticRegression` on-the-fly</span>
<span class="sd">    as a user (or simulated user) interacts with content</span>
<span class="sd">    via the web services provided by :mod:`dossier.web`.</span>

<span class="sd">    This reads :class:`~dossier.label.Label` objects from</span>
<span class="sd">    :class:`~dossier.label.LabelStore` and provides predictions of</span>
<span class="sd">    pairwise equivalence, which can be used for coreference resolution,</span>
<span class="sd">    clustering, and ranking.</span>

<span class="sd">    .. automethod:: dossier.models.PairwiseFeatureLearner.__init__</span>
<span class="sd">    .. automethod:: dossier.models.PairwiseFeatureLearner.probabilities</span>
<span class="sd">    &#39;&#39;&#39;</span>
<div class="viewcode-block" id="PairwiseFeatureLearner.__init__"><a class="viewcode-back" href="../../../dossier.models.html#dossier.models.pairwise.PairwiseFeatureLearner.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store</span><span class="p">,</span> <span class="n">label_store</span><span class="p">,</span> <span class="n">content_id</span><span class="p">,</span>
                 <span class="n">canopy_limit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">label_limit</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Build a new model.</span>

<span class="sd">        :param store: A store of feature collections.</span>
<span class="sd">        :type store: :class:`dossier.store.Store`</span>
<span class="sd">        :param label_store: A store of labels (ground truth data).</span>
<span class="sd">        :type label_store: :class:`dossier.label.LabelStore`</span>
<span class="sd">        :param str content_id: The query content id (which should correspond</span>
<span class="sd">                               to a feature collection in the ``store``).</span>
<span class="sd">                               If it doesn&#39;t, no results are returned.</span>
<span class="sd">        :param int canopy_limit: A limit on the number of results to return</span>
<span class="sd">                                 in the canopy (the initial index scan).</span>
<span class="sd">                                 This is meant to be a mechanism for resource</span>
<span class="sd">                                 control.</span>
<span class="sd">        :param int label_limit: A limit on the number of labels to use in</span>
<span class="sd">                                training. This is meant to be a mechanism for</span>
<span class="sd">                                resource control.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">store</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_store</span> <span class="o">=</span> <span class="n">label_store</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">query_content_id</span> <span class="o">=</span> <span class="n">content_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">query_fc</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">canopy_limit</span> <span class="o">=</span> <span class="n">canopy_limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_limit</span> <span class="o">=</span> <span class="n">label_limit</span>
</div>
<div class="viewcode-block" id="PairwiseFeatureLearner.probabilities"><a class="viewcode-back" href="../../../dossier.models.html#dossier.models.pairwise.PairwiseFeatureLearner.probabilities">[docs]</a>    <span class="k">def</span> <span class="nf">probabilities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Trains a model and predicts recommendations.</span>

<span class="sd">        If the query feature collection could not be found or if there</span>
<span class="sd">        is insufficient training data, an empty list is returned.</span>

<span class="sd">        Otherwise, a list of content objects (tuples of content</span>
<span class="sd">        id and feature collection) and probabilities is returned.</span>
<span class="sd">        The probability is generated from the model, and reflects</span>
<span class="sd">        confidence of the model that the corresponding content object</span>
<span class="sd">        is related to the query based on the ground truth data.</span>

<span class="sd">        On a large database, random samples are used for training, so</span>
<span class="sd">        this function is not deterministic.</span>

<span class="sd">        :rtype: ``list`` of</span>
<span class="sd">          ((``content_id``, :class:`dossier.fc.FeatureCollection`),</span>
<span class="sd">          probability)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">query_fc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_content_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_fc</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;Could not find FC for </span><span class="si">%s</span><span class="s">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_content_id</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c"># Try the canopy query before training, because if the canopy query</span>
        <span class="c"># gives us nothing, then there&#39;s no point in the additional work.</span>
        <span class="c">#</span>
        <span class="c"># Possible optimization: If the canopy query yields fewer than N</span>
        <span class="c"># results, then can we just return all of them? ---AG</span>
        <span class="c">#</span>
        <span class="c"># N.B Doing the canopy query first will cause things to be slower</span>
        <span class="c"># when there is insufficient training data.</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">canopy</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">canopy_limit</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s">&#39;Could not find any candidates in a canopy query by &#39;</span>
                <span class="s">&#39;scanning the following indexes: </span><span class="si">%s</span><span class="s">&#39;</span><span class="p">,</span>
                <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">index_names</span><span class="p">()))</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c"># Get labels from the database and translate them to the form</span>
        <span class="c"># `[{-1, 1}, i, j]` where `i, j` are indices into the list</span>
        <span class="c"># `content_objs`, which has type `[(content_id, FeatureCollection)]`.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;Fetching labels...&#39;</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_from_query</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">label_limit</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;Fetching FCs from labels...&#39;</span><span class="p">)</span>
        <span class="n">content_objs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">content_objs_from_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">indexed_labels</span> <span class="o">=</span> <span class="n">labels_to_indexed_coref_values</span><span class="p">(</span><span class="n">content_objs</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;Training...&#39;</span><span class="p">)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">train</span><span class="p">([</span><span class="n">fc</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">fc</span> <span class="ow">in</span> <span class="n">content_objs</span><span class="p">],</span> <span class="n">indexed_labels</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s">&#39;Could not train model: insufficient training data. &#39;</span>
                <span class="s">&#39;(query content id: </span><span class="si">%s</span><span class="s">)&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_content_id</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">InsufficientTrainingData</span>

        <span class="n">feature_names</span><span class="p">,</span> <span class="n">classifier</span><span class="p">,</span> <span class="n">transformer</span> <span class="o">=</span> <span class="n">model</span>
        <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">classify</span><span class="p">(</span>
            <span class="n">feature_names</span><span class="p">,</span> <span class="n">classifier</span><span class="p">,</span> <span class="n">transformer</span><span class="p">,</span> <span class="n">candidates</span><span class="p">))</span>
</div>
    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcs</span><span class="p">,</span> <span class="n">idx_labels</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Trains and returns a model using sklearn.</span>

<span class="sd">        If there are new labels to add, they can be added, returns an</span>
<span class="sd">        sklearn model which can be used for prediction and getting</span>
<span class="sd">        features.</span>

<span class="sd">        This method may return ``None`` if there is insufficient</span>
<span class="sd">        training data to produce a model.</span>

<span class="sd">        :param labels: Ground truth data.</span>
<span class="sd">        :type labels: list of ``({-1, 1}, index1, index2)``.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c"># We have insufficient training data when there is only one or</span>
        <span class="c"># fewer classes of labels.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">({</span><span class="n">lab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">idx_labels</span><span class="p">})</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="n">feature_names</span> <span class="o">=</span> <span class="n">vectorizable_features</span><span class="p">(</span><span class="n">fcs</span><span class="p">)</span>
        <span class="n">dis</span> <span class="o">=</span> <span class="n">dissimilarities</span><span class="p">(</span><span class="n">feature_names</span><span class="p">,</span> <span class="n">fcs</span><span class="p">)</span>

        <span class="n">phi_dicts</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>  <span class="c"># lists are in correspondence</span>
        <span class="k">for</span> <span class="n">coref_value</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">idx_labels</span><span class="p">:</span>
            <span class="c"># i, j are indices into the list `fcs`</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coref_value</span><span class="p">)</span>  <span class="c"># either -1 or 1</span>
            <span class="n">phi_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">dis</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">feature_names</span><span class="p">})</span>

        <span class="n">vec</span> <span class="o">=</span> <span class="n">dict_vector</span><span class="p">()</span>
        <span class="n">training_data</span> <span class="o">=</span> <span class="n">vec</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">phi_dicts</span><span class="p">)</span>

        <span class="n">model</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">class_weight</span><span class="o">=</span><span class="s">&#39;auto&#39;</span><span class="p">,</span> <span class="n">penalty</span><span class="o">=</span><span class="s">&#39;l1&#39;</span><span class="p">)</span>
        <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">training_data</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">feature_names</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">vec</span>

    <span class="k">def</span> <span class="nf">classify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feature_names</span><span class="p">,</span> <span class="n">classifier</span><span class="p">,</span> <span class="n">transformer</span><span class="p">,</span> <span class="n">candidates</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns ``[probability]`` in correspondence with</span>
<span class="sd">        ``candidates``.</span>

<span class="sd">        Where each ``probability`` corresponds to the probability that</span>
<span class="sd">        the corresponding candidate is classified with a positive label</span>
<span class="sd">        given the training data.</span>

<span class="sd">        The list returned is in correspondence with the list of</span>
<span class="sd">        candidates given.</span>

<span class="sd">        N.B. The contract of this method should be simplified by</span>
<span class="sd">        bundling ``feature_names``, ``classifier`` and ``transformer``</span>
<span class="sd">        into one thing known as &quot;the model.&quot; ---AG</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">dis</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">feature_names</span><span class="p">:</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">dict_vector</span><span class="p">()</span>
            <span class="n">query</span> <span class="o">=</span> <span class="n">vec</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">query_fc</span><span class="p">[</span><span class="n">name</span><span class="p">]])</span>
            <span class="n">cans</span> <span class="o">=</span> <span class="n">vec</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">fc</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">fc</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">)</span>
            <span class="n">dis</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">pairwise_distances</span><span class="p">(</span>
                <span class="n">cans</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s">&#39;cosine&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>

        <span class="c"># in correspondence with `candidates`</span>
        <span class="n">phi_dicts</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
            <span class="p">[{</span><span class="n">name</span><span class="p">:</span> <span class="n">dis</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">feature_names</span><span class="p">}</span>
             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">))])</span>
        <span class="k">return</span> <span class="n">classifier</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">phi_dicts</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">canopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">streaming_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">canopy_ids</span><span class="p">(</span><span class="n">limit_hint</span><span class="o">=</span><span class="n">hard_limit</span><span class="p">(</span><span class="n">limit</span><span class="p">)),</span>
                               <span class="n">limit</span><span class="p">,</span> <span class="n">hard_limit</span><span class="p">(</span><span class="n">limit</span><span class="p">))</span>
        <span class="c"># I don&#39;t think it ever makes sense to include the query</span>
        <span class="c"># as part of the candidate set.</span>
        <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">fc</span><span class="p">):</span> <span class="n">fc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">get_many</span><span class="p">(</span><span class="n">ids</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">canopy_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit_hint</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">limit_hint</span> <span class="o">=</span> <span class="n">limit_hint</span> <span class="ow">or</span> <span class="mi">1000</span>
        <span class="c"># TODO: It seems like this should pre-emptively discard content</span>
        <span class="c"># ids that have already participated in a *direct* label with</span>
        <span class="c"># the query. But I think this is a premature optimization since</span>
        <span class="c"># the filtering functions will take care of it. (This optimization</span>
        <span class="c"># would mean fewer kernel computations.)</span>
        <span class="n">blacklist</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">query_content_id</span><span class="p">}</span>
        <span class="n">cids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c"># OK, so it turns out that a naive index scan is pretty inflexible and</span>
        <span class="c"># arbitrary. The issue is that in a big enough data set, the first</span>
        <span class="c"># index scan will probably exhaust all of our result set, which</span>
        <span class="c"># means result sets will never see any variety.</span>
        <span class="c">#</span>
        <span class="c"># Instead, we&#39;ll try to sample from each index in small batch sizes.</span>
        <span class="c"># This is a heuristic; not a principled approach. ---AG</span>
        <span class="n">index_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">index_names</span><span class="p">()</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">limit_hint</span> <span class="o">/</span> <span class="mi">10</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c"># idx, name |--&gt; last end</span>
        <span class="c"># When `progress` is empty, the following loop will terminate.</span>
        <span class="c"># An index is removed from `progress` when it no longer produces</span>
        <span class="c"># results.</span>
        <span class="k">for</span> <span class="n">idx_name</span> <span class="ow">in</span> <span class="n">index_names</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_fc</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">idx_name</span><span class="p">,</span> <span class="p">{}):</span>
                <span class="n">progress</span><span class="p">[(</span><span class="n">idx_name</span><span class="p">,</span> <span class="n">name</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;starting index scan (query content id: </span><span class="si">%s</span><span class="s">)&#39;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">query_content_id</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx_name</span> <span class="ow">in</span> <span class="n">index_names</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_fc</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">idx_name</span><span class="p">,</span> <span class="p">{}):</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx_name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">progress</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;[StringCounter index: </span><span class="si">%s</span><span class="s">] scanning for &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span><span class="p">,</span>
                                <span class="n">idx_name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                    <span class="n">scanner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">index_scan</span><span class="p">(</span><span class="n">idx_name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                    <span class="n">progressed</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">islice</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">progress</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="bp">None</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">progressed</span> <span class="o">&gt;=</span> <span class="n">batch_size</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="k">if</span> <span class="n">cid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cids</span> <span class="ow">and</span> <span class="n">cid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">blacklist</span><span class="p">:</span>
                            <span class="n">cids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cid</span><span class="p">)</span>
                            <span class="n">progressed</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">yield</span> <span class="n">cid</span>
                    <span class="k">if</span> <span class="n">progressed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">progress</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">progress</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="n">progressed</span>

    <span class="k">def</span> <span class="nf">labels_from_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;ContentId -&gt; [Label]&#39;&#39;&#39;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;Getting connected component&#39;</span><span class="p">)</span>
        <span class="n">pos_component</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_store</span><span class="o">.</span><span class="n">connected_component</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">query_content_id</span><span class="p">)</span>
        <span class="n">pos_component</span> <span class="o">=</span> <span class="n">streaming_sample</span><span class="p">(</span>
            <span class="n">pos_component</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">hard_limit</span><span class="p">(</span><span class="n">limit</span><span class="p">))</span>
        <span class="n">pos_expanded</span> <span class="o">=</span> <span class="n">expand_labels</span><span class="p">(</span><span class="n">pos_component</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;Getting negative labels&#39;</span><span class="p">)</span>

        <span class="c"># It turns out that inferring negative labels actually takes quite</span>
        <span class="c"># a bit of time. I think this is because we are being a bit overeager</span>
        <span class="c"># in how we&#39;re adding negative labels in the first place.</span>
        <span class="c"># We should revisit this when negative labels are applied more</span>
        <span class="c"># judiciously.</span>
        <span class="c"># negatives = self.label_store.negative_inference(</span>
            <span class="c"># self.query_content_id)</span>
        <span class="n">negatives</span> <span class="o">=</span> <span class="n">ifilter</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">CorefValue</span><span class="o">.</span><span class="n">Negative</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_store</span><span class="o">.</span><span class="n">directly_connected</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_content_id</span><span class="p">))</span>

        <span class="c"># This tomfoolery makes sure that if there are positive and</span>
        <span class="c"># negative labels, then we&#39;ll grab at least one of each.</span>
        <span class="c"># (It doesn&#39;t matter if we return a little more than `limit` labels.)</span>
        <span class="n">pos_sample</span> <span class="o">=</span> <span class="n">streaming_sample</span><span class="p">(</span>
            <span class="n">chain</span><span class="p">(</span><span class="n">pos_component</span><span class="p">,</span> <span class="n">pos_expanded</span><span class="p">),</span>
            <span class="n">limit</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">hard_limit</span><span class="p">(</span><span class="n">limit</span><span class="p">))</span>
        <span class="n">neg_sample</span> <span class="o">=</span> <span class="n">streaming_sample</span><span class="p">(</span>
            <span class="n">negatives</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">hard_limit</span><span class="p">(</span><span class="n">limit</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pos_sample</span> <span class="o">+</span> <span class="n">neg_sample</span>

    <span class="k">def</span> <span class="nf">content_objs_from_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;[Label] -&gt; [(content_id, FeatureCollection)]&#39;&#39;&#39;</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="n">ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lab</span><span class="o">.</span><span class="n">content_id1</span><span class="p">)</span>
            <span class="n">ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lab</span><span class="o">.</span><span class="n">content_id2</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">ifilter</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">cid</span><span class="p">,</span> <span class="n">fc</span><span class="p">):</span> <span class="n">fc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">get_many</span><span class="p">(</span><span class="n">ids</span><span class="p">)))</span>

</div>
<span class="k">def</span> <span class="nf">labels_to_indexed_coref_values</span><span class="p">(</span><span class="n">content_objs</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;[(content_id, FeatureCollection)] -&gt; [Label] -&gt; [({-1,1}, i, j)]</span>

<span class="sd">    where 0 &lt;= i, j &lt; len(content_objs).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">cids_to_idx</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">content_id</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">content_objs</span><span class="p">):</span>
        <span class="n">cids_to_idx</span><span class="p">[</span><span class="n">content_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">cid</span><span class="p">:</span> <span class="n">cids_to_idx</span><span class="p">[</span><span class="n">cid</span><span class="p">]</span>
    <span class="n">labs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">lab</span><span class="o">.</span><span class="n">content_id1</span> <span class="ow">in</span> <span class="n">cids_to_idx</span> <span class="ow">and</span> <span class="n">lab</span><span class="o">.</span><span class="n">content_id2</span> <span class="ow">in</span> <span class="n">cids_to_idx</span><span class="p">:</span>
            <span class="n">labs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lab</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">idx</span><span class="p">(</span><span class="n">lab</span><span class="o">.</span><span class="n">content_id1</span><span class="p">),</span> <span class="n">idx</span><span class="p">(</span><span class="n">lab</span><span class="o">.</span><span class="n">content_id2</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">labs</span>


<span class="k">def</span> <span class="nf">vectorizable_features</span><span class="p">(</span><span class="n">fcs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Discovers the ordered set of vectorizable features in ``fcs``.</span>

<span class="sd">    Returns a list of feature names, sorted lexicographically.</span>
<span class="sd">    Feature names are only included if the corresponding</span>
<span class="sd">    features are vectorizable (i.e., they are an instance of</span>
<span class="sd">    :class:`collections.Mapping`).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">is_mapping</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Mapping</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">({</span><span class="n">name</span> <span class="k">for</span> <span class="n">fc</span> <span class="ow">in</span> <span class="n">fcs</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">fc</span> <span class="k">if</span> <span class="n">is_mapping</span><span class="p">(</span><span class="n">fc</span><span class="p">[</span><span class="n">name</span><span class="p">])})</span>


<span class="k">def</span> <span class="nf">dissimilarities</span><span class="p">(</span><span class="n">feature_names</span><span class="p">,</span> <span class="n">fcs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Computes the pairwise dissimilarity matrices.</span>

<span class="sd">    This returns a dictionary mapping each name in ``feature_names``</span>
<span class="sd">    to a pairwise dissimilarities matrix. The dissimilaritiy scores</span>
<span class="sd">    correspond to ``1 - kernel`` between each feature of each</span>
<span class="sd">    pair of feature collections in ``fcs``.</span>

<span class="sd">    (The kernel used is currently fixed to ``cosine`` distance.)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">dis</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">feature_names</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;computing pairwise dissimilarity matrix &#39;</span>
                    <span class="s">&#39;for </span><span class="si">%d</span><span class="s"> of </span><span class="si">%d</span><span class="s"> features (current feature: </span><span class="si">%s</span><span class="s">)&#39;</span><span class="p">,</span>
                    <span class="n">count</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">feature_names</span><span class="p">),</span> <span class="n">name</span><span class="p">)</span>
        <span class="c">## opportunity to use joblib is buried down inside call to</span>
        <span class="c">## pairwise_distances...</span>
        <span class="c"># And it&#39;s fixed to `n_jobs=1` because running multiprocessing</span>
        <span class="c"># inside py.test causes weird problems. It also doesn&#39;t seem like a</span>
        <span class="c"># good idea to do it inside a web server either. ---AG</span>
        <span class="n">dis</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">pairwise_distances</span><span class="p">(</span>
            <span class="n">dict_vector</span><span class="p">()</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">fc</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">fc</span> <span class="ow">in</span> <span class="n">fcs</span><span class="p">),</span>
            <span class="n">metric</span><span class="o">=</span><span class="s">&#39;cosine&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dis</span>


<span class="k">def</span> <span class="nf">dict_vector</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">DictVectorizer</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">hard_limit</span><span class="p">(</span><span class="n">limit</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">limit</span> <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">limit</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">str_to_max_int</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">maximum</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">maximum</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">maximum</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">dossier 0.3.0 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2014, Diffeo, Inc..
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3b2.
    </div>
  </body>
</html>